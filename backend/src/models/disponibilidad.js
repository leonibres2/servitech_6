/**
 * üìÖ MODELO DE DISPONIBILIDAD DE EXPERTOS - SERVITECH
 * Gestiona los horarios disponibles de los expertos.
 * Este archivo define el esquema y los m√©todos para la gesti√≥n de la disponibilidad de los expertos en la plataforma ServiTech.
 * Fecha: 6 de julio de 2025
 *
 * Permite almacenar, consultar y actualizar los horarios recurrentes, bloques no disponibles, slots especiales y configuraciones personalizadas.
 * Incluye m√©todos para generar slots disponibles, verificar disponibilidad y bloquear per√≠odos.
 */

// Importa mongoose, la biblioteca ODM para MongoDB, y extrae el constructor Schema para definir el modelo.
const mongoose = require("mongoose");
const { Schema } = mongoose;

// Define el esquema principal de disponibilidad, con todos los campos y subdocumentos necesarios.
const disponibilidadSchema = new Schema(
  {
    // üë®‚Äçüíº Experto al que pertenece la disponibilidad
    experto: {
      type: Schema.Types.ObjectId,
      ref: "Usuario",
      required: true,
    },

    // üìÖ Configuraci√≥n de horarios recurrentes
    horarioRecurrente: {
      habilitado: { type: Boolean, default: true },
      horarios: [
        {
          diaSemana: {
            type: Number, // 0=Domingo, 1=Lunes, ... 6=S√°bado
            required: true,
            min: 0,
            max: 6,
          },
          horaInicio: {
            type: String, // Formato "HH:mm" (ej: "09:00")
            required: true,
            match: /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/,
          },
          horaFin: {
            type: String, // Formato "HH:mm" (ej: "18:00")
            required: true,
            match: /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/,
          },
          activo: { type: Boolean, default: true },
        },
      ],
    },

    // üö´ Bloques espec√≠ficos no disponibles
    bloquesNoDisponibles: [
      {
        fechaInicio: { type: Date, required: true },
        fechaFin: { type: Date, required: true },
        motivo: {
          type: String,
          enum: [
            "vacaciones",
            "enfermedad",
            "capacitacion",
            "personal",
            "mantenimiento",
          ],
          required: true,
        },
        descripcion: String,
        fechaCreacion: { type: Date, default: Date.now },
      },
    ],

    // ‚è∞ Slots espec√≠ficos habilitados (fuera del horario normal)
    slotsEspeciales: [
      {
        fecha: { type: Date, required: true },
        horaInicio: { type: String, required: true },
        horaFin: { type: String, required: true },
        duracion: { type: Number, default: 60 }, // minutos
        precio: Number, // Precio especial si aplica
        motivo: String,
        fechaCreacion: { type: Date, default: Date.now },
      },
    ],

    // ‚öôÔ∏è Configuraciones del experto
    configuracion: {
      duracionMinima: { type: Number, default: 30 }, // minutos
      duracionMaxima: { type: Number, default: 120 }, // minutos
      incrementos: { type: Number, default: 30 }, // cada cu√°ntos minutos
      tiempoAnticipacion: { type: Number, default: 120 }, // minutos de anticipaci√≥n m√≠nima
      tiempoMaximoReserva: { type: Number, default: 30 }, // d√≠as m√°ximos para reservar
      pausaEntreAsesorias: { type: Number, default: 15 }, // minutos entre asesor√≠as

      // üí∞ Precios por duraci√≥n
      precios: [
        {
          duracion: Number,
          precio: Number,
        },
      ],

      // üåç Zona horaria
      zonaHoraria: { type: String, default: "America/Bogota" },

      // üì± Notificaciones
      notificaciones: {
        nuevaReserva: { type: Boolean, default: true },
        recordatorio: { type: Boolean, default: true },
        tiempoRecordatorio: { type: Number, default: 60 }, // minutos antes
      },
    },

    // üìä Estado general
    activo: { type: Boolean, default: true },
    fechaCreacion: { type: Date, default: Date.now },
    fechaActualizacion: { type: Date, default: Date.now },
  },
  {
    timestamps: true,
    collection: "disponibilidades",
  }
);

// üìå √çndices para optimizar consultas
disponibilidadSchema.index({ experto: 1 });
disponibilidadSchema.index({
  "bloquesNoDisponibles.fechaInicio": 1,
  "bloquesNoDisponibles.fechaFin": 1,
});
disponibilidadSchema.index({ "slotsEspeciales.fecha": 1 });

// üîÑ Middleware para actualizar fechaActualizacion
disponibilidadSchema.pre("save", function (next) {
  this.fechaActualizacion = new Date();
  next();
});

// üìã M√©todos del modelo
disponibilidadSchema.methods = {
  // Verificar si un d√≠a est√° disponible
  estaDiaDisponible(fecha) {
    const diaSemana = fecha.getDay();
    const horarioDelDia = this.horarioRecurrente.horarios.find(
      (h) => h.diaSemana === diaSemana && h.activo
    );

    if (!horarioDelDia) return false;

    // Verificar bloques no disponibles
    const estaBloquedo = this.bloquesNoDisponibles.some(
      (bloque) => fecha >= bloque.fechaInicio && fecha <= bloque.fechaFin
    );

    return !estaBloquedo;
  },

  // Obtener horario de un d√≠a espec√≠fico
  obtenerHorarioDia(fecha) {
    const diaSemana = fecha.getDay();
    const horario = this.horarioRecurrente.horarios.find(
      (h) => h.diaSemana === diaSemana && h.activo
    );

    if (!horario) return null;

    return {
      horaInicio: horario.horaInicio,
      horaFin: horario.horaFin,
      duracionMinima: this.configuracion.duracionMinima,
      incrementos: this.configuracion.incrementos,
    };
  },

  // Generar slots disponibles para una fecha
  generarSlotsDisponibles(fecha, asesoriesExistentes = []) {
    const slots = [];
    const horario = this.obtenerHorarioDia(fecha);

    if (!horario || !this.estaDiaDisponible(fecha)) {
      return slots;
    }

    // Convertir horarios a minutos desde medianoche
    const [inicioHora, inicioMin] = horario.horaInicio.split(":").map(Number);
    const [finHora, finMin] = horario.horaFin.split(":").map(Number);

    const inicioMinutos = inicioHora * 60 + inicioMin;
    const finMinutos = finHora * 60 + finMin;

    // Generar slots cada X minutos
    for (
      let minutos = inicioMinutos;
      minutos < finMinutos;
      minutos += this.configuracion.incrementos
    ) {
      const horaSlot = Math.floor(minutos / 60);
      const minSlot = minutos % 60;

      const fechaHoraSlot = new Date(fecha);
      fechaHoraSlot.setHours(horaSlot, minSlot, 0, 0);

      // Verificar que no hay conflicto con asesor√≠as existentes
      const hayConflicto = asesoriesExistentes.some((asesoria) => {
        const inicioAsesoria = new Date(asesoria.fechaHora);
        const finAsesoria = new Date(
          inicioAsesoria.getTime() + asesoria.duracion * 60000
        );
        const finSlot = new Date(
          fechaHoraSlot.getTime() + this.configuracion.duracionMinima * 60000
        );

        return fechaHoraSlot < finAsesoria && finSlot > inicioAsesoria;
      });

      if (!hayConflicto) {
        slots.push({
          fechaHora: fechaHoraSlot,
          disponible: true,
          duracionesDisponibles: this.configuracion.precios.map((p) => ({
            duracion: p.duracion,
            precio: p.precio,
          })),
        });
      }
    }

    return slots;
  },

  // Bloquear un per√≠odo
  bloquearPeriodo(fechaInicio, fechaFin, motivo, descripcion = "") {
    this.bloquesNoDisponibles.push({
      fechaInicio,
      fechaFin,
      motivo,
      descripcion,
      fechaCreacion: new Date(),
    });
    return this.save();
  },
};

// üìä M√©todos est√°ticos
disponibilidadSchema.statics = {
  // Buscar disponibilidad por experto
  async porExperto(expertoId) {
    return this.findOne({ experto: expertoId, activo: true });
  },

  // Crear disponibilidad por defecto para nuevo experto
  async crearPorDefecto(expertoId) {
    const horarioDefecto = [
      { diaSemana: 1, horaInicio: "09:00", horaFin: "17:00", activo: true }, // Lunes
      { diaSemana: 2, horaInicio: "09:00", horaFin: "17:00", activo: true }, // Martes
      { diaSemana: 3, horaInicio: "09:00", horaFin: "17:00", activo: true }, // Mi√©rcoles
      { diaSemana: 4, horaInicio: "09:00", horaFin: "17:00", activo: true }, // Jueves
      { diaSemana: 5, horaInicio: "09:00", horaFin: "17:00", activo: true }, // Viernes
    ];

    const preciosDefecto = [
      { duracion: 30, precio: 50000 },
      { duracion: 60, precio: 90000 },
      { duracion: 90, precio: 130000 },
      { duracion: 120, precio: 160000 },
    ];

    return this.create({
      experto: expertoId,
      horarioRecurrente: {
        habilitado: true,
        horarios: horarioDefecto,
      },
      configuracion: {
        duracionMinima: 30,
        duracionMaxima: 120,
        incrementos: 30,
        tiempoAnticipacion: 120,
        tiempoMaximoReserva: 30,
        pausaEntreAsesorias: 15,
        precios: preciosDefecto,
        zonaHoraria: "America/Bogota",
      },
      activo: true,
    });
  },

  // Obtener slots disponibles para m√∫ltiples expertos
  async obtenerSlotsMultiples(expertosIds, fechaInicio, fechaFin) {
    const resultados = {};

    for (const expertoId of expertosIds) {
      const disponibilidad = await this.porExperto(expertoId);
      if (disponibilidad) {
        resultados[expertoId] = await disponibilidad.generarSlotsDisponibles(
          fechaInicio
        );
      }
    }

    return resultados;
  },
};

module.exports = mongoose.model("Disponibilidad", disponibilidadSchema);
