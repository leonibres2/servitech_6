/**
 * üí¨ MODELO DE MENSAJER√çA EN TIEMPO REAL - SERVITECH
 * Sistema completo de mensajer√≠a con Socket.io
 * Fecha: 6 de julio de 2025
 *
 * Este archivo define los esquemas y modelos para las conversaciones y mensajes en tiempo real.
 * Permite gestionar chats individuales y grupales, mensajes multimedia, estados, reacciones, estad√≠sticas y notificaciones.
 * Incluye m√©todos para operaciones comunes y optimizaci√≥n de consultas.
 *
 * Cada bloque y campo est√° documentado para explicar su prop√≥sito, funcionamiento y la intenci√≥n de su implementaci√≥n.
 */

// Importa mongoose, la biblioteca ODM para MongoDB, y extrae el constructor Schema para definir los modelos.
const mongoose = require("mongoose");
const { Schema } = mongoose;

// üì± Esquema para conversaciones/chats
// Define el esquema de una conversaci√≥n, incluyendo participantes, estado, estad√≠sticas y configuraci√≥n.
// Cada conversaci√≥n puede estar asociada a una asesor√≠a, tener m√∫ltiples participantes y almacenar estad√≠sticas de mensajes.
const conversacionSchema = new Schema(
  {
    // üÜî Identificaci√≥n
    codigoConversacion: {
      type: String,
      unique: true,
      required: true,
      default: function () {
        return `CONV-${Date.now()}-${Math.random()
          .toString(36)
          .substr(2, 6)
          .toUpperCase()}`;
      },
    },

    // üë• Participantes
    participantes: [
      {
        usuario: {
          type: Schema.Types.ObjectId,
          ref: "Usuario",
          required: true,
        },
        rol: {
          type: String,
          enum: ["cliente", "experto", "moderador", "admin"],
          default: "cliente",
        },
        fechaIngreso: { type: Date, default: Date.now },
        activo: { type: Boolean, default: true },
        ultimaConexion: Date,
        enLinea: { type: Boolean, default: false },
        permisos: {
          puedeEnviar: { type: Boolean, default: true },
          puedeEliminar: { type: Boolean, default: false },
          puedeModerar: { type: Boolean, default: false },
        },
      },
    ],

    // üîó Relaci√≥n con asesor√≠a (opcional)
    asesoria: {
      type: Schema.Types.ObjectId,
      ref: "Asesoria",
    },

    // üìã Informaci√≥n del chat
    titulo: {
      type: String,
      maxlength: 200,
    },
    tipo: {
      type: String,
      enum: ["individual", "grupal", "asesoria", "soporte", "general"],
      default: "individual",
    },
    descripcion: String,

    // üìä Estado y estad√≠sticas
    estado: {
      type: String,
      enum: ["activa", "pausada", "cerrada", "archivada"],
      default: "activa",
    },
    estadisticas: {
      totalMensajes: { type: Number, default: 0 },
      ultimoMensaje: {
        contenido: String,
        remitente: {
          type: Schema.Types.ObjectId,
          ref: "Usuario",
        },
        fecha: Date,
        tipo: String,
      },
      mensajesNoLeidos: [
        {
          usuario: {
            type: Schema.Types.ObjectId,
            ref: "Usuario",
          },
          cantidad: { type: Number, default: 0 },
        },
      ],
    },

    // ‚öôÔ∏è Configuraci√≥n
    configuracion: {
      notificacionesActivas: { type: Boolean, default: true },
      modoSilencioso: { type: Boolean, default: false },
      tiempoExpiracion: Date,
      encriptada: { type: Boolean, default: false },
      permitirArchivos: { type: Boolean, default: true },
      tama√±oMaximoArchivo: { type: Number, default: 10485760 }, // 10MB
    },

    // üì± Estado
    activa: { type: Boolean, default: true },
    archivada: { type: Boolean, default: false },
    fechaCreacion: { type: Date, default: Date.now },
    fechaUltimaActividad: { type: Date, default: Date.now },
    fechaCierre: Date,
  },
  {
    timestamps: true,
    collection: "conversaciones",
  }
);

// üí¨ Esquema para mensajes individuales
const mensajeSchema = new Schema(
  {
    // üîó Relaci√≥n con conversaci√≥n
    conversacion: {
      type: Schema.Types.ObjectId,
      ref: "Conversacion",
      required: true,
    },

    // üë§ Remitente
    remitente: {
      type: Schema.Types.ObjectId,
      ref: "Usuario",
      required: true,
    },

    // üìù Contenido del mensaje
    contenido: {
      texto: {
        type: String,
        maxlength: 5000,
      },
      tipo: {
        type: String,
        enum: [
          "texto",
          "imagen",
          "archivo",
          "audio",
          "video",
          "ubicacion",
          "contacto",
          "sistema",
        ],
        default: "texto",
      },
      archivo: {
        url: String,
        nombre: String,
        tama√±o: Number, // en bytes
        mimeType: String,
      },
      metadatos: {
        duracion: Number, // para audio/video en segundos
        dimensiones: {
          ancho: Number,
          alto: Number,
        },
        ubicacion: {
          latitud: Number,
          longitud: Number,
          direccion: String,
        },
        vista_previa: String, // URL de thumbnail
      },
    },

    // ‚è∞ Informaci√≥n temporal
    fechaEnvio: {
      type: Date,
      default: Date.now,
    },
    fechaEntrega: Date,
    fechaLectura: [
      {
        usuario: {
          type: Schema.Types.ObjectId,
          ref: "Usuario",
        },
        fecha: { type: Date, default: Date.now },
      },
    ],

    // üìä Estado del mensaje en tiempo real
    estado: {
      type: String,
      enum: ["enviando", "enviado", "entregado", "leido", "error"],
      default: "enviando",
    },

    // üîÑ Edici√≥n y modificaci√≥n
    editado: {
      editado: { type: Boolean, default: false },
      fechaEdicion: Date,
      historialEdiciones: [
        {
          contenido: String,
          fecha: { type: Date, default: Date.now },
        },
      ],
    },

    // üí¨ Respuesta a otro mensaje (threading)
    respuestaA: {
      type: Schema.Types.ObjectId,
      ref: "Mensaje",
    },

    // ‚≠ê Reacciones y interacciones
    reacciones: [
      {
        usuario: {
          type: Schema.Types.ObjectId,
          ref: "Usuario",
        },
        tipo: {
          type: String,
          enum: [
            "like",
            "love",
            "laugh",
            "angry",
            "sad",
            "wow",
            "thumbs_up",
            "thumbs_down",
          ],
          default: "like",
        },
        fecha: { type: Date, default: Date.now },
      },
    ],

    // üóëÔ∏è Eliminaci√≥n
    eliminado: {
      eliminado: { type: Boolean, default: false },
      fechaEliminacion: Date,
      eliminadoPor: {
        type: Schema.Types.ObjectId,
        ref: "Usuario",
      },
      razon: String,
    },

    // üîê Seguridad y moderaci√≥n
    moderacion: {
      reportado: { type: Boolean, default: false },
      aprobado: { type: Boolean, default: true },
      razonReporte: String,
      moderadoPor: {
        type: Schema.Types.ObjectId,
        ref: "Usuario",
      },
    },

    // üì° Informaci√≥n t√©cnica para tiempo real
    socketInfo: {
      socketId: String,
      ipAddress: String,
      userAgent: String,
    },

    // üéØ Prioridad y urgencia
    prioridad: {
      type: String,
      enum: ["baja", "normal", "alta", "urgente"],
      default: "normal",
    },
  },
  {
    timestamps: true,
    collection: "mensajes",
  }
);

// üìå √çndices para optimizar consultas
conversacionSchema.index({
  "participantes.usuario": 1,
  fechaUltimaActividad: -1,
});
conversacionSchema.index({ asesoria: 1 });
conversacionSchema.index({ estado: 1, fechaUltimaActividad: -1 });
// codigoConversacion ya tiene √≠ndice unique autom√°tico

mensajeSchema.index({ conversacion: 1, fechaEnvio: -1 });
mensajeSchema.index({ remitente: 1, fechaEnvio: -1 });
mensajeSchema.index({ "contenido.tipo": 1 });
mensajeSchema.index({ estado: 1 });
mensajeSchema.index({ "eliminado.eliminado": 1, fechaEnvio: -1 });

// üîÑ Middleware para actualizar estad√≠sticas
mensajeSchema.pre("save", async function (next) {
  if (this.isNew) {
    // Actualizar estad√≠sticas de la conversaci√≥n
    await mongoose.model("Conversacion").findByIdAndUpdate(this.conversacion, {
      $inc: { "estadisticas.totalMensajes": 1 },
      $set: {
        "estadisticas.ultimoMensaje": {
          contenido: this.contenido.texto?.substring(0, 100) || "[Archivo]",
          remitente: this.remitente,
          fecha: this.fechaEnvio,
          tipo: this.contenido.tipo,
        },
        fechaUltimaActividad: new Date(),
      },
    });

    // Incrementar contador de mensajes no le√≠dos para otros participantes
    const conversacion = await mongoose
      .model("Conversacion")
      .findById(this.conversacion);
    if (conversacion) {
      const otrosParticipantes = conversacion.participantes.filter(
        (p) => p.usuario.toString() !== this.remitente.toString()
      );

      for (const participante of otrosParticipantes) {
        await mongoose.model("Conversacion").updateOne(
          {
            _id: this.conversacion,
            "estadisticas.mensajesNoLeidos.usuario": participante.usuario,
          },
          { $inc: { "estadisticas.mensajesNoLeidos.$.cantidad": 1 } }
        );
      }
    }
  }
  next();
});

// üìã M√©todos del modelo Mensaje
mensajeSchema.methods = {
  // Marcar como le√≠do por un usuario
  async marcarComoLeido(usuarioId) {
    if (this.remitente.toString() !== usuarioId.toString()) {
      // Agregar a la lista de lectura si no est√°
      const yaLeido = this.fechaLectura.some(
        (l) => l.usuario.toString() === usuarioId.toString()
      );

      if (!yaLeido) {
        this.fechaLectura.push({
          usuario: usuarioId,
          fecha: new Date(),
        });

        // Actualizar estado si todos los participantes han le√≠do
        const conversacion = await mongoose
          .model("Conversacion")
          .findById(this.conversacion);
        const totalParticipantes = conversacion.participantes.filter(
          (p) => p.usuario.toString() !== this.remitente.toString()
        ).length;

        if (this.fechaLectura.length >= totalParticipantes) {
          this.estado = "leido";
        } else if (this.estado === "enviado") {
          this.estado = "entregado";
        }

        // Decrementar contador de no le√≠dos
        await mongoose.model("Conversacion").updateOne(
          {
            _id: this.conversacion,
            "estadisticas.mensajesNoLeidos.usuario": usuarioId,
          },
          { $inc: { "estadisticas.mensajesNoLeidos.$.cantidad": -1 } }
        );

        await this.save();
      }
    }
  },

  // Editar mensaje
  async editarMensaje(nuevoContenido) {
    if (this.editado.historialEdiciones.length < 5) {
      // M√°ximo 5 ediciones
      this.editado.historialEdiciones.push({
        contenido: this.contenido.texto,
        fecha: new Date(),
      });
    }

    this.contenido.texto = nuevoContenido;
    this.editado.editado = true;
    this.editado.fechaEdicion = new Date();

    return this.save();
  },

  // Agregar reacci√≥n
  async agregarReaccion(usuarioId, tipoReaccion) {
    // Remover reacci√≥n anterior del mismo usuario
    this.reacciones = this.reacciones.filter(
      (r) => r.usuario.toString() !== usuarioId.toString()
    );

    // Agregar nueva reacci√≥n
    this.reacciones.push({
      usuario: usuarioId,
      tipo: tipoReaccion,
      fecha: new Date(),
    });

    return this.save();
  },

  // Eliminar mensaje
  async eliminarMensaje(usuarioId, razon = "") {
    this.eliminado.eliminado = true;
    this.eliminado.fechaEliminacion = new Date();
    this.eliminado.eliminadoPor = usuarioId;
    this.eliminado.razon = razon;

    return this.save();
  },
};

// üìã M√©todos del modelo Conversaci√≥n
conversacionSchema.methods = {
  // Agregar participante
  async agregarParticipante(usuarioId, rol = "cliente") {
    const yaExiste = this.participantes.some(
      (p) => p.usuario.toString() === usuarioId.toString()
    );

    if (!yaExiste) {
      this.participantes.push({
        usuario: usuarioId,
        rol: rol,
        fechaIngreso: new Date(),
        activo: true,
      });

      // Inicializar contador de mensajes no le√≠dos
      this.estadisticas.mensajesNoLeidos.push({
        usuario: usuarioId,
        cantidad: 0,
      });

      return this.save();
    }
    return this;
  },

  // Remover participante
  async removerParticipante(usuarioId) {
    this.participantes = this.participantes.map((p) => {
      if (p.usuario.toString() === usuarioId.toString()) {
        p.activo = false;
      }
      return p;
    });

    return this.save();
  },

  // Verificar si usuario es participante activo
  esParticipante(usuarioId) {
    return this.participantes.some(
      (p) => p.usuario.toString() === usuarioId.toString() && p.activo
    );
  },

  // Obtener mensajes no le√≠dos para un usuario
  getMensajesNoLeidos(usuarioId) {
    const participante = this.estadisticas.mensajesNoLeidos.find(
      (p) => p.usuario.toString() === usuarioId.toString()
    );
    return participante ? participante.cantidad : 0;
  },

  // Marcar todos los mensajes como le√≠dos
  async marcarTodosComoLeidos(usuarioId) {
    await mongoose.model("Mensaje").updateMany(
      {
        conversacion: this._id,
        remitente: { $ne: usuarioId },
        estado: { $in: ["enviado", "entregado"] },
      },
      {
        $push: {
          fechaLectura: {
            usuario: usuarioId,
            fecha: new Date(),
          },
        },
        $set: { estado: "leido" },
      }
    );

    // Resetear contador
    await this.constructor.updateOne(
      {
        _id: this._id,
        "estadisticas.mensajesNoLeidos.usuario": usuarioId,
      },
      { $set: { "estadisticas.mensajesNoLeidos.$.cantidad": 0 } }
    );
  },

  // Actualizar estado de conexi√≥n de participante
  async actualizarEstadoConexion(usuarioId, enLinea) {
    await this.constructor.updateOne(
      {
        _id: this._id,
        "participantes.usuario": usuarioId,
      },
      {
        $set: {
          "participantes.$.enLinea": enLinea,
          "participantes.$.ultimaConexion": new Date(),
        },
      }
    );
  },
};

// üìä M√©todos est√°ticos
conversacionSchema.statics = {
  // Buscar conversaciones de un usuario
  async porUsuario(usuarioId, filtros = {}) {
    const query = {
      "participantes.usuario": usuarioId,
      "participantes.activo": true,
      activa: true,
      ...filtros,
    };

    return this.find(query)
      .populate(
        "participantes.usuario",
        "nombre apellido avatar_url es_experto"
      )
      .populate("estadisticas.ultimoMensaje.remitente", "nombre apellido")
      .populate("asesoria", "titulo fechaHora estado")
      .sort({ fechaUltimaActividad: -1 });
  },

  // Crear conversaci√≥n entre usuarios
  async crearConversacion(
    usuario1Id,
    usuario2Id,
    tipo = "individual",
    asesoriaId = null
  ) {
    // Verificar si ya existe una conversaci√≥n entre estos usuarios
    const conversacionExistente = await this.findOne({
      tipo: tipo,
      "participantes.usuario": { $all: [usuario1Id, usuario2Id] },
      participantes: { $size: 2 },
      activa: true,
    });

    if (conversacionExistente && !asesoriaId) {
      return conversacionExistente;
    }

    const nuevaConversacion = new this({
      participantes: [
        { usuario: usuario1Id, rol: "cliente" },
        { usuario: usuario2Id, rol: "experto" },
      ],
      tipo: tipo,
      asesoria: asesoriaId,
      estadisticas: {
        mensajesNoLeidos: [
          { usuario: usuario1Id, cantidad: 0 },
          { usuario: usuario2Id, cantidad: 0 },
        ],
      },
    });

    return nuevaConversacion.save();
  },

  // Obtener estad√≠sticas globales
  async estadisticasGlobales() {
    const pipeline = [
      { $match: { activa: true } },
      {
        $group: {
          _id: "$tipo",
          total: { $sum: 1 },
          totalMensajes: { $sum: "$estadisticas.totalMensajes" },
          ultimaActividad: { $max: "$fechaUltimaActividad" },
        },
      },
    ];

    return this.aggregate(pipeline);
  },
};

module.exports = {
  Conversacion: mongoose.model("Conversacion", conversacionSchema),
  Mensaje: mongoose.model("Mensaje", mensajeSchema),
};
